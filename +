<!DOCTYPE html>
<html lang="es">
<head>
  <title>three.js webgl - instancing test (trees)</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>

  <div id="container"></div>

  <script src="js/three/three.min.js"></script>

  <script src="js/controls/TrackballControls.js"></script>

  <script id="vertexShader" type="x-shader/x-vertex">
    precision highp float;
    uniform mat4 modelViewMatrix;
    uniform mat4 projectionMatrix;
    uniform mat4 normalMatrix;

    uniform sampler2D map;
    uniform vec2 uv;

    attribute vec3 position;
    attribute vec3 normal;
    attribute vec3 instancePosition;
    attribute float instanceScale;

    vec3 transform( inout vec3 position, vec3 T, float S) {
      position *= S / 15.;
      position.z *= 1.5;
      position += T;
      vec4 mdt = texture2D( map, ( position.xy + 1000. ) / 2000. );
      position.z += mdt.x * 900.;
      return position;
    }
    varying vec3 vPos;
    varying vec3 vNormal;

    void main(){
      
      vec3 pos = position;
      vNormal = normal;
      transform( pos, instancePosition, instanceScale );
      vec3 positionEye = ( modelViewMatrix * vec4( position, 1. ) ).xyz;
      vPos = positionEye;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );
    }

  </script>

  <script id="fragmentShader" type="x-shader/x-fragment">

    precision highp float;
    varying vec3 vPos;
    varying vec3 vNormal;

    void main() {

      float diffuse = dot( vNormal, normalize( vec3( 0.1, -0.1, 1.0 ) ) );

      gl_FragColor = vec4( diffuse * vec3( 0., .5, 0. ), 1. );

    }

  </script>

  <script id="planeVertexShader" type="x-shader/x-vertex">
  
    precision highp float;
    uniform sampler2D map;

    void main(){
      
      vec3 pos = position;
      vec4 mdt = texture2D( map, uv );
      pos.z = mdt.x * 900;
      gl_position = projectionMatrix * modelViewMatrix * vec4( pos, 1.0 );

    }

  </script>

  <script id="planeFragmentShader" type="x-shader/x-fragment">

    precision highp float;

    void main() {

      gl_FragColor = vec4( .6, .6, 0., 1. );

    }

  </script>

  <script>

    var container;

    var camera, scene, renderer;

    var controls;

    var densityArray, density, heightArray, normals;

    // init();
    // animate();

  function load_density() {
    var img = new XMLHttpRequest();
    img.responseType = 'arraybuffer';
    img.open('GET', 'images/d.tif', true);
    img.onload = function (e) {
      if (img.readyState === 4) {
          if (img.status === 200) {
              var arrayBuffer = e.target.response;
              var byteArray = new Uint8Array(arrayBuffer);
              densityArray = byteArray.slice( 536 ).map( function( a ) {
                return a / 10;
              })
              density = densityArray.reduce(function( a, b ) { 
                return a + b;
              });
              init();
              animate();
              console.log( density );
              }
        }
      };
    img.send(null);
  }

  function load_image() {
    var img = new XMLHttpRequest();
    img.responseType = 'arraybuffer';
    img.open('GET', 'images/arbolado.tif', true);
    img.onload = function (e) {
      if (img.readyState === 4) {
          if (img.status === 200) {
              var arrayBuffer = e.target.response;
              var byteArray = new Uint8Array(arrayBuffer);
              heightArray = byteArray.slice(496);
              console.log(heightArray);
              load_density();
          }
        }
      }
    img.send(null);
  }
    


  //load_image();
  var loader = new THREE.BufferGeometryLoader();
  loader.load('arbol.json', function(geo) {
    byteArray = geo.attributes.position.clone();
    normals = geo.attributes.normal.clone();
    console.log(byteArray)
    load_image();
  });

    function init() {

      container = document.getElementById( 'container' );

      camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 10000 );
      camera.position.z = 4000;

      scene = new THREE.Scene();

      instancedGeometry = new THREE.InstancedBufferGeometry;

      instancedGeometry.addAttribute( 'position', byteArray );
      instancedGeometry.addAttribute( 'normal', normals );

      var instancePositions = new Float32Array( density * 3 );
      var instanceScales = new Float32Array( density );
      var iterator = 0;
      var scalesIterator = 0;

      for ( i = 0; i < 80; i++ ) {
        for ( n = 0; n < 80; n++ ) {
          
          var index = ( i * 80 ) + n;
          var it = densityArray[ index ];


          for ( j = 0; j < it; j++ ) {

            instancePositions[ iterator++ ] = ( n * 25 ) - 1000 + ( Math.random() - 0.5 ) * 25 ;
            instancePositions[ iterator++ ] = 1000 - ( i * 25)  + ( Math.random() - 0.5 ) * 25;
            instancePositions[ iterator++ ] = 0 ;

            instanceScales[ scalesIterator++ ] = heightArray[ index ];

          }
        }
      }

      var mdt = new THREE.TextureLoader().load('images/mdt.png');
      console.log(mdt);

      instancedGeometry.addAttribute( 'instancePosition', new THREE.InstancedBufferAttribute( instancePositions, 3, 'normalized' ) );
      instancedGeometry.addAttribute( 'instanceScale', new THREE.InstancedBufferAttribute( instanceScales, 1, 'normalized' ) );

      var shaderMaterial = new THREE.RawShaderMaterial( {

        uniforms: {
            map: { type: "t", value: mdt},
        },
        vertexShader: document.getElementById( 'vertexShader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
        vertexColors: true

      } );

      // counterparts are drawn all at once with a single draw call (via instanced rendering)

      var instancedMesh = new THREE.Mesh( instancedGeometry, shaderMaterial );
      scene.add( instancedMesh );

      // PLANO 

      var planeGeometry = new THREE.PlaneGeometry( 2000, 2000, 80, 80 );
      var planeMaterial = new THREE.ShaderMaterial( {

        uniforms: {
            map: { type: "t", value: mdt},
        },
        vertexShader: document.getElementById( 'planeVertexShader' ).textContent,
        fragmentShader: document.getElementById( 'planeFragmentShader' ).textContent,

      });

      var plane = new THREE.Mesh( planeGeometry, planeMaterial );
      scene.add( plane );

      renderer = new THREE.WebGLRenderer();
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      container.appendChild( renderer.domElement );

      controls = new THREE.TrackballControls( camera, renderer.domElement );

      if ( renderer.extensions.get( 'ANGLE_instanced_arrays' ) === null ) {

        document.getElementById( 'notSupported' ).style.display = '';
        return;

      }

      window.addEventListener( 'resize', onWindowResize, false );

    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize( window.innerWidth, window.innerHeight );

    }

    //

    function animate() {

      requestAnimationFrame( animate );

      render();

    }

    function render() {

      controls.update();

      renderer.render( scene, camera );

    }

  </script>

</body>

</html>
